module build.make;

import std.format : format;
import build.log;

/**
Build System:

Rules are made up of target files and actions.

The "target files" are generated by the corresponding actions.
When the actions are executed, it is expected to generate the target
files

How to know whether a rule needs to be executed?

1. If any target files do not exist, then execute it.
2. Otherwise, each rule will have a set of dependency files. This list
   will have been generated when the action is executed.  If any dependency
   file is newer than any target file, then the action is executed.

How to find dependency files.

When checking the rule, actions to execute are used to lookup in a database what
the dependency files are.  This could be done by hashing the actions and then
using that as a filename to a list of files.
*/

class MakeException : Exception
{
    this(string msg)
    {
        super(msg);
    }
}

class Rule
{
    private enum State
    {
        initial,
        activated, // means the rule needs to be built
        built, // rule is already built
    }

    private string[] targets;
    private string[] actions;
    private State state;
}

private struct RuleAdder
{
    Make* make;
    Rule rule;
    this(Make* make, Rule rule)
    {
        this.make = make;
        this.rule = rule;
    }
    RuleAdder* target(string name)
    {
        auto existing = make.ruleMap.get(name, null);
        if (existing !is null)
            throw new MakeException(format("multiple rules with the same target '%s'", name));
        make.ruleMap[name] = rule;
        rule.targets ~= name;
        return &this;
    }
    RuleAdder* action(string action)
    {
        rule.actions ~= action;
        return &this;
    }
}

struct Make
{
    import std.array : Appender;

    
    private string depDir;    
    private Appender!(Rule[]) rules; // list of all rules
    private Rule[string] ruleMap; // map from rule targets to rules

    auto rule()
    {
        auto rule = new Rule();
        rules.put(rule);
        return RuleAdder(&this, rule);
    }
    void addRule(Rule rule)
    {
        if (rule.targets.length == 0)
            throw new MakeException("every rule must have at least 1 target");
        rules.put(rule);
        foreach (target; rule.targets)
        {
            auto existing = ruleMap.get(target, null);
            if (existing !is null)
                throw new MakeException(format("multiple rules with the same target '%s'", target));
            ruleMap[target] = rule;
        }
    }
    void build(string[] targets)
    {
        foreach (target; targets)
        {
            build(target);
        }
    }
    void build(string target)
    {
        import std.file : exists;

        auto rule = ruleMap.get(target, null);
        if (!rule)
            throw new MakeException(format("no rule matches target '%s'", target));
        if (rule.state == Rule.State.built)
            return;
        if (rule.state != Rule.State.initial)
            assert(0, "not impl");
        foreach (ruleTarget; rule.targets)
        {
            if (!exists(ruleTarget))
            {
                verbosef("rule: activated because target '%s' does not exist", ruleTarget);
                return executeRule(rule);
            }
            verbosef("rule: target '%s' exists", ruleTarget);
        }
        assert(0, "not impl");
    }
    private void executeRule(Rule rule)
    {
        assert(rule.state == Rule.State.initial, "code bug");
        rule.state = Rule.State.activated;

        
    }
    void dump()
    {
        foreach (ref rule; rules.data)
        {
            import std.stdio;
            writefln("Rule: %s %s", rule.targets, rule.actions);
        }
    }
}

unittest
{
    auto make = Make("deps");
    make.rule
        .target("a")
        .action("echo hello > a")
        ;
    make.dump();
    make.build("a");
}
